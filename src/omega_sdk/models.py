"""
Pydantic models for OMEGA SDK.

These models are derived from the Federation Core OpenAPI spec and represent
the canonical contract between SDK and Federation Core.
"""

from datetime import datetime
from enum import Enum
from typing import Any, Optional
from pydantic import BaseModel, Field


# ============================================================================
# Envelope & Meta (Core Response Structure)
# ============================================================================


class Meta(BaseModel):
    """Response metadata present in every Federation Core response."""

    correlation_id: str = Field(..., description="Correlation ID echoed from request")
    request_id: str = Field(..., description="Unique request ID generated by Federation Core")
    ts: datetime = Field(..., description="Server timestamp (ISO 8601)")
    sdk: Optional[dict[str, str]] = Field(None, description="SDK metadata (name, version)")


class Error(BaseModel):
    """Error details present when ok=false."""

    code: str = Field(..., description="Error code (e.g., VALIDATION_FAILED)")
    message: str = Field(..., description="Human-readable error message")
    details: Optional[dict[str, Any]] = Field(None, description="Additional error details")
    retryable: bool = Field(..., description="Whether the error is retryable")


class Envelope(BaseModel):
    """Standard response envelope for all Federation Core responses."""

    ok: bool = Field(..., description="Success indicator")
    data: Optional[Any] = Field(None, description="Response data (null on error)")
    error: Optional[Error] = Field(None, description="Error details (null on success)")
    meta: Meta = Field(..., description="Response metadata")


# ============================================================================
# Pagination
# ============================================================================


class Page(BaseModel):
    """Pagination metadata."""

    limit: int = Field(..., description="Items per page")
    next_cursor: Optional[str] = Field(None, description="Cursor for next page (null if last)")


# ============================================================================
# Agents
# ============================================================================


class AgentKind(str, Enum):
    """Agent classification."""

    TITAN = "titan"
    AGENT = "agent"
    TOOL = "tool"


class AgentStatus(str, Enum):
    """Agent operational status."""

    ONLINE = "online"
    OFFLINE = "offline"
    DEGRADED = "degraded"


class Agent(BaseModel):
    """Agent registration details."""

    agent_id: str = Field(..., description="Unique agent identifier")
    kind: AgentKind = Field(..., description="Agent classification")
    display_name: Optional[str] = Field(None, description="Human-readable name")
    status: AgentStatus = Field(..., description="Operational status")
    capabilities: Optional[list[str]] = Field(None, description="Agent capabilities")
    endpoints: Optional[dict[str, str]] = Field(None, description="Protocol endpoints (mcp, http)")
    tools: Optional[list[str]] = Field(None, description="Tool IDs provided by this agent")
    metadata: Optional[dict[str, Any]] = Field(None, description="Agent metadata")


class AgentListResponse(BaseModel):
    """Response data for GET /agents."""

    items: list[Agent] = Field(..., description="List of agents")
    page: Page = Field(..., description="Pagination metadata")


# ============================================================================
# Tools
# ============================================================================


class ToolStatus(str, Enum):
    """Tool operational status."""

    READY = "ready"
    UNAVAILABLE = "unavailable"
    DEPRECATED = "deprecated"


class Tool(BaseModel):
    """Tool definition and metadata."""

    tool_id: str = Field(..., description="Unique tool identifier")
    display_name: Optional[str] = Field(None, description="Human-readable name")
    description: Optional[str] = Field(None, description="Tool description")
    agent_id: str = Field(..., description="Agent that provides this tool")
    schema_version: Optional[str] = Field(None, description="Schema version")
    input_schema: Optional[dict[str, Any]] = Field(None, description="JSON Schema for input")
    output_schema: Optional[dict[str, Any]] = Field(None, description="JSON Schema for output")
    tags: Optional[list[str]] = Field(None, description="Tool tags")
    limits: Optional[dict[str, Any]] = Field(
        None, description="Tool limits (max_payload_bytes, timeout_ms)"
    )
    status: ToolStatus = Field(..., description="Operational status")


class ToolListResponse(BaseModel):
    """Response data for GET /tools."""

    items: list[Tool] = Field(..., description="List of tools")
    page: Page = Field(..., description="Pagination metadata")


# ============================================================================
# Tool Invocation
# ============================================================================


class ToolInvokeOptions(BaseModel):
    """Tool invocation options."""

    timeout_ms: Optional[int] = Field(None, description="Request timeout in milliseconds")
    stream: Optional[bool] = Field(False, description="Enable streaming response")


class ToolInvokeContext(BaseModel):
    """Governance context for tool invocation."""

    tenant_id: str = Field(..., description="Tenant identifier")
    actor_id: str = Field(..., description="Actor identifier")
    correlation_id: str = Field(..., description="Correlation ID (canonical format)")
    decision_receipt_id: Optional[str] = Field(
        None, description="Decision receipt ID (if required by policy)"
    )
    tags: Optional[list[str]] = Field(None, description="Policy tags (e.g., silentapply, prod)")


class ToolInvokeRequest(BaseModel):
    """Request body for POST /tools/{tool_id}:invoke."""

    input: dict[str, Any] = Field(..., description="Tool input parameters")
    options: Optional[ToolInvokeOptions] = Field(None, description="Invocation options")
    context: ToolInvokeContext = Field(..., description="Governance context")


class ToolInvokeAudit(BaseModel):
    """Audit metadata for tool invocation."""

    event_id: str = Field(..., description="Audit event ID")
    keon_receipt_id: Optional[str] = Field(None, description="Keon receipt ID (if governed)")
    evidence_pack_id: Optional[str] = Field(None, description="Evidence pack ID (if applicable)")


class ToolInvokeResult(BaseModel):
    """Response data for POST /tools/{tool_id}:invoke."""

    tool_id: str = Field(..., description="Tool that was invoked")
    result: dict[str, Any] = Field(..., description="Tool output")
    usage: Optional[dict[str, Any]] = Field(None, description="Usage metadata (duration_ms, etc)")
    audit: Optional[ToolInvokeAudit] = Field(None, description="Audit metadata")


# ============================================================================
# Tasks (Asynchronous Orchestration)
# ============================================================================


class TaskStatus(str, Enum):
    """Task execution status."""

    QUEUED = "queued"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class TaskRouting(BaseModel):
    """Task routing configuration."""

    strategy: Optional[str] = Field(None, description="Routing strategy (capability, etc)")
    capability: Optional[str] = Field(None, description="Required capability")
    # Additional routing fields as needed


class TaskGovernance(BaseModel):
    """Task governance configuration."""

    require_receipt: Optional[bool] = Field(None, description="Require decision receipt")
    decision_receipt_id: Optional[str] = Field(None, description="Pre-decided receipt ID")
    policy_tags: Optional[list[str]] = Field(None, description="Policy tags")


class TaskContext(BaseModel):
    """Task execution context."""

    tenant_id: str = Field(..., description="Tenant identifier")
    actor_id: str = Field(..., description="Actor identifier")
    correlation_id: str = Field(..., description="Correlation ID (canonical format)")


class TaskCreateRequest(BaseModel):
    """Request body for POST /tasks."""

    task_type: str = Field(..., description="Task type (workflow.run, etc)")
    input: dict[str, Any] = Field(..., description="Task input")
    routing: Optional[TaskRouting] = Field(None, description="Routing configuration")
    governance: Optional[TaskGovernance] = Field(None, description="Governance configuration")
    context: TaskContext = Field(..., description="Execution context")


class TaskCreateResponse(BaseModel):
    """Response data for POST /tasks."""

    task_id: str = Field(..., description="Unique task identifier")
    status: TaskStatus = Field(..., description="Initial task status (usually queued)")
    created_at: datetime = Field(..., description="Task creation timestamp")


class TaskState(BaseModel):
    """Task execution state."""

    current_step: Optional[str] = Field(None, description="Current execution step")
    progress: Optional[float] = Field(None, description="Progress indicator (0.0 - 1.0)")
    # Additional state fields as needed


class TaskAudit(BaseModel):
    """Task audit metadata."""

    keon_receipt_id: Optional[str] = Field(None, description="Keon receipt ID (if governed)")
    evidence_pack_id: Optional[str] = Field(None, description="Evidence pack ID (if applicable)")


class Task(BaseModel):
    """Task details and status."""

    task_id: str = Field(..., description="Unique task identifier")
    status: TaskStatus = Field(..., description="Current task status")
    state: Optional[TaskState] = Field(None, description="Execution state")
    result: Optional[dict[str, Any]] = Field(None, description="Task result (null if not complete)")
    audit: Optional[TaskAudit] = Field(None, description="Audit metadata")


# ============================================================================
# Health
# ============================================================================


class HealthStatus(BaseModel):
    """Health check response data."""

    status: str = Field(..., description="Status indicator (ok, degraded, error)")
    version: str = Field(..., description="Federation Core version")
    uptime_s: int = Field(..., description="Uptime in seconds")


class DependencyHealth(BaseModel):
    """Dependency health status."""

    redis: str = Field(..., description="Redis status")
    mongo: str = Field(..., description="MongoDB status")
    keon_runtime: str = Field(..., description="Keon runtime status")


class BuildInfo(BaseModel):
    """Build information."""

    git_sha: str = Field(..., description="Git commit SHA")
    built_at: datetime = Field(..., description="Build timestamp")


class StatusResponse(BaseModel):
    """Rich status response data."""

    status: str = Field(..., description="Overall status")
    dependencies: DependencyHealth = Field(..., description="Dependency health")
    build: BuildInfo = Field(..., description="Build information")
